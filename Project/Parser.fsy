%{
 (* File Fun/FunPar.fsy 
    Parser for micro-ML, a small functional language; one-argument functions.
    P. Sestoft, 2009-10-19
    C. Tinelli, 2016-10-19
  *)

 open Absyn;
%}

/* TODO: How to add RBRAK LBRAK FNASSIGN NAT ? */

/* TODO: which tokens go where? */
%token <int> CSTINT
%token <string> NAME
%token <bool> CSTBOOL 
%token BOOL ELSE END FALSE FN FUN HD IF IN INT ISE LIST LOCAL NOT NULL PRINT REC THEN TRUE UNIT VAR
%token RETARROW TL
%token PLUS MINUS TIMES DIV
%token EQ NE LT LTE DBLCOL SEMICOL COL
%token LPAR RPAR 
%token EOF

/* lowest precedence  */
%right SEMICOL RETARROW
%nonassoc IF
%left ELSE              
%left EQ NE 
%nonassoc LT LTE
%right DBLCOL
%left PLUS MINUS
%left TIMES DIV 
%nonassoc NOT HD TL ISE LIST PRINT F /* TODO: How to handle F? What is TL? */
/* highest precedence  */

%start Main
%type <Absyn.expr> Main Expr AtExpr Const
%type <Absyn.expr> AppExpr

%%

Main:
    Expr EOF                            { $1 }
;

/* TODO: How to handle {} ? */
Expr:
    AtExpr                              { $1                      }
  | AppExpr                             { $1                      }
  | IF Expr THEN Expr ELSE Expr         { If ($2, $4, $6)         }
  | NOT Expr                            {}
  | HD  Expr                            {}
  | TL  Expr                            {}
  | ISE Expr                            {}
  | PRINT Expr                          {}
  | Expr PLUS    Expr                     { Prim ("+",  $1, $3)     }
  | Expr MINUS   Expr                     { Prim ("-",  $1, $3)     }
  | Expr TIMES   Expr                     { Prim ("*",  $1, $3)     }
  | Expr DIV     Expr                     { Prim ("/",  $1, $3)     } 
  | Expr EQ      Expr                     { Prim ("=",  $1, $3)     }
  | Expr NE      Expr                     { Prim ("<>", $1, $3)     }
  | Expr LT      Expr                     { Prim ("<",  $1, $3)     }
  | Expr LTE     Expr                     { Prim ("<=",  $1, $3)     }
  | Expr DBLCOL  Expr                     { Prim ("::",  $1, $3)     }
  | Expr COL     Expr                     { Prim (";",  $1, $3)     }
;

/* TODO: What is this opperator? => */
AtExpr:
    Const                               { $1                      }
  | NAME                                { Var $1                  }
  | LOCAL Bindings in Expr END          {}
  | FN TypedName FNASSIGN Expr END      { AssignFn ($2, $4)       }
  | LPAR Expr RPAR                      { $2                      }
  | LPAR LBRAK RBRAK COL type RPAR      {}
;

Const:
    NAT                                     {}
  | TRUE
  | FALSE
  | NULL
;

Bindings:
    binding                             {}
  | binding binding                     {}
;

Binding:
    VAR NAME EQ Expr                            { $4 } /* ? */
    FUN NAME TypedName EQ Expr                  { AssignFun ($3, $5) }
    FUN REC NAME TypedName COL Type EQ Expr     { AssignRecFun ($4, $5, $7) }
;

AppExpr:
    AtExpr AtExpr                       { Call ($1, $2)           }
  | AppExpr AtExpr                      { Call ($1, $2)           }
;

Const:
    CSTINT                              { CstI ($1)               }
  | CSTBOOL                             { CstB ($1)               }
;

Type:
   UNIT                                 {}
 | INT                                  {}
 | Type RETARROW Type                   {}
 | Type LIST                            {}
 | LPAR Type RPAR                       {}
;
